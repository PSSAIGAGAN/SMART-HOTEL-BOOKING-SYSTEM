package com.hotel.service;

import com.hotel.client.RoomClient; // Assuming you have this Feign client
import com.hotel.entity.Hotel;
import com.hotel.model.HotelDTO;
import com.hotel.model.RoomDTO; // Assuming this DTO is in your Hotel-MS
import com.hotel.repository.HotelRepository;
import org.modelmapper.ModelMapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate; // ⭐ NEW: Import RestTemplate
import org.springframework.web.multipart.MultipartFile;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.ArrayList;
import java.util.List;
import java.util.OptionalDouble;
import java.util.UUID;
import java.util.stream.Collectors;

@Service
public class HotelServiceImpl implements HotelService {
    private static final Logger logger = LoggerFactory.getLogger(HotelServiceImpl.class);

    private static final String UPLOAD_DIR = "Uploads/";

    @Autowired
    private RoomClient roomClient; // Used for rooms integration

    @Autowired
    private HotelRepository hotelRepository;

    @Autowired
    private ModelMapper modelMapper;

    // ⭐ NEW: Autowire RestTemplate (ensure you have a @Bean for it in a config or main class)
    @Autowired
    private RestTemplate restTemplate;

    // ⭐ Helper method to process hotels: filter by available rooms, find min price, and get average rating
    private List<HotelDTO> processHotels(List<Hotel> hotels) {
        List<HotelDTO> resultHotels = new ArrayList<>();

        for (Hotel hotel : hotels) {
            HotelDTO hotelDTO = modelMapper.map(hotel, HotelDTO.class);

            // 1. Fetch rooms and set minPrice
            try {
                List<RoomDTO> rooms = roomClient.getRoomsByHotel(hotel.getHotelId());
                logger.info("Fetched {} rooms for hotel ID {}", rooms.size(), hotel.getHotelId());

                OptionalDouble minAvailablePrice = rooms.stream()
                    .filter(RoomDTO::getAvailability)
                    .mapToDouble(RoomDTO::getPrice)
                    .min();

                minAvailablePrice.ifPresent(price -> hotelDTO.setMinPrice(price));

                // If no available rooms, minPrice will not be set.
                // We'll still include the hotel, but minPrice might be null and rating might be 0.0.
                // If you want to filter out hotels with no *available* rooms, keep the 'if (minAvailablePrice.isPresent())' block
                // around `resultHotels.add(hotelDTO);` as it was in your original code.
                // For now, I'm separating it to ensure all hotels are listed, but with N/A or 0 if rooms/ratings are missing.

            } catch (Exception e) {
                logger.error("Error fetching or processing rooms for hotel ID {}: {}", hotel.getHotelId(), e.getMessage());
                hotelDTO.setMinPrice(null); // Explicitly set to null on error
            }

            // ⭐ 2. Fetch Average Rating from Review Microservice
            try {
                // Using Eureka Service Name for inter-service communication (REVIEW-SERVICE)
                String reviewServiceUrl = "http://REVIEW-SERVICE/review-api/reviews/average-rating/hotel/" + hotel.getHotelId();
                ResponseEntity<Double> response = restTemplate.getForEntity(reviewServiceUrl, Double.class);

                if (response.getStatusCode().is2xxSuccessful() && response.getBody() != null) {
                    hotelDTO.setRating(response.getBody()); // ⭐ Set the 'rating' field with the average
                } else {
                    hotelDTO.setRating(0.0); // Default to 0.0 if no rating found or empty response
                }
            } catch (Exception e) {
                logger.error("Error fetching average rating for hotel ID {}: {}", hotel.getHotelId(), e.getMessage());
                hotelDTO.setRating(0.0); // Default to 0.0 on error
            }

            // Decide whether to add the hotel to results based on minPrice presence
            // If you only want to show hotels that have at least one available room:
            if (hotelDTO.getMinPrice() != null) { // Or rooms.stream().anyMatch(RoomDTO::getAvailability) if you want to be strict
                 resultHotels.add(hotelDTO);
            } else {
                 logger.info("Hotel ID {} has no available rooms, filtering it out from search results.", hotel.getHotelId());
            }

            // If you want to show all hotels, even those without available rooms, and just mark minPrice as N/A:
            // resultHotels.add(hotelDTO);
        }
        return resultHotels;
    }

    @Override
    public HotelDTO addHotel(HotelDTO hotelDTO) {
        Hotel hotel = modelMapper.map(hotelDTO, Hotel.class);
        // Ensure managerId is handled as Long in entity from String in DTO
        if (hotelDTO.getManagerId() != null && !hotelDTO.getManagerId().isEmpty()) {
            hotel.setManagerId(Long.parseLong(hotelDTO.getManagerId()));
        }
        // When adding a new hotel, its initial average rating is 0.0
        if (hotel.getRating() == null) {
            hotel.setRating(0.0);
        }

        Hotel savedHotel = hotelRepository.save(hotel);
        // After saving, you might want to return the DTO with initial minPrice/rating,
        // but for newly added hotels, reviews and rooms won't exist yet, so minPrice will be null and rating 0.0.
        // If you need minPrice immediately upon add, you'd have to add dummy rooms or skip this for 'add'.
        HotelDTO resultDto = modelMapper.map(savedHotel, HotelDTO.class);
        resultDto.setMinPrice(null); // Initially no rooms/minPrice
        resultDto.setRating(0.0); // Initially no reviews/rating
        return resultDto;
    }

    @Override
    public HotelDTO getHotelById(Long id) {
        logger.info("Fetching hotel with ID: {}", id);
        Hotel hotel = hotelRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Hotel not found with ID: " + id));

        HotelDTO hotelDTO = modelMapper.map(hotel, HotelDTO.class);

        // Fetch rooms and set minPrice for a single hotel
        try {
            List<RoomDTO> rooms = roomClient.getRoomsByHotel(hotel.getHotelId());
            OptionalDouble minAvailablePrice = rooms.stream()
                .filter(RoomDTO::getAvailability)
                .mapToDouble(RoomDTO::getPrice)
                .min();
            minAvailablePrice.ifPresent(hotelDTO::setMinPrice);
        } catch (Exception e) {
            logger.error("Error fetching rooms for single hotel ID {}: {}", hotel.getHotelId(), e.getMessage());
            hotelDTO.setMinPrice(null);
        }

        // ⭐ Fetch Average Rating for a single hotel
        try {
            String reviewServiceUrl = "http://REVIEW-SERVICE/review-api/reviews/average-rating/hotel/" + hotel.getHotelId();
            ResponseEntity<Double> response = restTemplate.getForEntity(reviewServiceUrl, Double.class);
            if (response.getStatusCode().is2xxSuccessful() && response.getBody() != null) {
                hotelDTO.setRating(response.getBody()); // ⭐ Set the 'rating' field with the average
            } else {
                hotelDTO.setRating(0.0);
            }
        } catch (Exception e) {
            logger.error("Error fetching average rating for single hotel ID {}: {}", hotel.getHotelId(), e.getMessage());
            hotelDTO.setRating(0.0);
        }

        return hotelDTO;
    }

    @Override
    public List<String> getAllHotelLocations() {
        return hotelRepository.findAll().stream()
            .map(Hotel::getLocation)
            .filter(loc -> loc != null && !loc.trim().isEmpty())
            .collect(Collectors.toList());
    }

    @Override
    public List<HotelDTO> getAllHotels() {
        List<Hotel> hotels = hotelRepository.findAll();
        return processHotels(hotels); // Use the helper method
    }

    @Override
    public List<HotelDTO> getHotelsByLocation(String location) {
        List<Hotel> hotels = hotelRepository.findByLocationContainingIgnoreCase(location);
        return processHotels(hotels); // Use the helper method
    }

    @Override
    public HotelDTO updateHotel(Long id, HotelDTO hotelDTO) {
        Hotel existingHotel = hotelRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Hotel not found with ID: " + id));

        // Map incoming DTO to existing entity
        modelMapper.map(hotelDTO, existingHotel);

        // Explicitly set managerId from DTO's String to Entity's Long
        if (hotelDTO.getManagerId() != null && !hotelDTO.getManagerId().isEmpty()) {
            existingHotel.setManagerId(Long.parseLong(hotelDTO.getManagerId()));
        }

        // Preserve current rating (which is already the average from past fetches)
        // or re-fetch it if you want to ensure it's always fresh on update.
        // For simplicity, we'll keep the current average rating, as it's not directly updated by hotel details.
        // If a review changes, the average will be updated the next time getHotelById or getAllHotels is called.

        Hotel updatedHotel = hotelRepository.save(existingHotel);

        // Return the updated hotel DTO, re-processing it to include minPrice and current average rating
        return getHotelById(updatedHotel.getHotelId()); // This will fetch current minPrice and average rating
    }

    @Override
    public boolean deleteHotelById(Long id) {
        try {
            roomClient.deleteAllRoomsByHotelId(id);
            logger.info("Successfully deleted rooms for hotel ID: {}", id);
        } catch (Exception e) {
            logger.error("Failed to delete rooms for hotel ID {}: {}", id, e.getMessage());
        }
        hotelRepository.deleteById(id);
        return true;
    }

    @Override
    public boolean deleteAllHotels() {
        List<Hotel> allHotels = hotelRepository.findAll();
        for (Hotel hotel : allHotels) {
            try {
                roomClient.deleteAllRoomsByHotelId(hotel.getHotelId());
                logger.info("Successfully deleted rooms for hotel ID: {}", hotel.getHotelId());
            } catch (Exception e) {
                logger.error("Failed to delete rooms for hotel ID {} during deleteAllHotels: {}", hotel.getHotelId(), e.getMessage());
            }
        }
        hotelRepository.deleteAll();
        return true;
    }

    @Override
    public String storeImage(MultipartFile file) {
        try {
            File uploadDir = new File(UPLOAD_DIR);
            if (!uploadDir.exists()) {
                uploadDir.mkdirs();
            }

            String filename = UUID.randomUUID() + "_" + file.getOriginalFilename();
            Path filePath = Paths.get(UPLOAD_DIR, filename);
            Files.copy(file.getInputStream(), filePath, StandardCopyOption.REPLACE_EXISTING);

            return "http://localhost:8081/uploads/" + filename;
        } catch (IOException e) {
            throw new RuntimeException("Failed to store image", e);
        }
    }

    @Override
    public List<RoomDTO> getRoomsForHotel(Long hotelId) {
        return roomClient.getRoomsByHotel(hotelId);
    }
}